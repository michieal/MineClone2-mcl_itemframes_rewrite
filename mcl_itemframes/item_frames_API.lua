---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by michieal.
--- DateTime: 10/26/22 1:16 AM
---

mcl_itemframes = {}
mcl_itemframes.item_frame_base = {}
mcl_itemframes.glow_frame_base = {}
mcl_itemframes.frames_registered = {}
mcl_itemframes.frames_registered.glowing = {}
mcl_itemframes.frames_registered.standard = {}

local S = minetest.get_translator(minetest.get_current_modname())
local table = table
local DEBUG = false

if 1 == 1 then
    minetest.log("action", "[mcl_itemframes] API initialized.")
end

local VISUAL_SIZE = 0.3
local facedir = {}
facedir[0] = { x = 0, y = 0, z = 1 }
facedir[1] = { x = 1, y = 0, z = 0 }
facedir[2] = { x = 0, y = 0, z = -1 }
facedir[3] = { x = -1, y = 0, z = 0 }
local pi = math.pi

local glow_amount = 6 -- LIGHT_MAX is 15, but the items aren't supposed to be a light source.

local remove_item_entity = function(pos, node)
    if node.name == "mcl_itemframes:item_frame" or node.name == "mcl_itemframes:glow_item_frame" then
        for _, obj in pairs(minetest.get_objects_inside_radius(pos, 0.5)) do
            local entity = obj:get_luaentity()

            if 1 == 1 then
                if entity then
                    minetest.log("action", "[mcl_itemframes] Remove_Entity: Attempting to remove Entity Named: " .. entity.name)
                else
                    minetest.log("action", "[mcl_itemframes] Remove_Entity: Attempting to remove Entity Named: entity not found.\n can be a false positive.")
                end
            end

            if entity then
                if entity.name == "mcl_itemframes:item" or entity.name == "mcl_itemframes:map" or
                        entity.name == "mcl_itemframes:glow_item" or entity.name == "mcl_itemframes:glow_map" then
                    if 1 == 1 then
                        minetest.log("action", "[mcl_itemframes] Remove_Entity: Removing Entity Named: " .. entity.name)
                    end
                    obj:remove()
                end
            end
        end
    end
end

mcl_itemframes.update_item_glow_entity = function(pos, node, param2)

    if 1 == 1 then
        minetest.log("action", "[mcl_itemframes] Update_Glow_Item:\nPosition: " .. dump(pos) .. "\nNode: " .. dump(node))
    end

    remove_item_entity(pos, node)
    local meta = minetest.get_meta(pos)
    local inv = meta:get_inventory()
    local item = inv:get_stack("main", 1)
    if not item:is_empty() then
        if not param2 then
            param2 = node.param2
        end
        if node.name == "mcl_itemframes:glow_item_frame" then
            local posad = facedir[param2]
            pos.x = pos.x + posad.x * 6.5 / 16
            pos.y = pos.y + posad.y * 6.5 / 16
            pos.z = pos.z + posad.z * 6.5 / 16
        end
        local yaw = pi * 2 - param2 * pi / 2
        local map_id = item:get_meta():get_string("mcl_maps:id")
        local map_id_entity = {}
        local map_id_lua = {}

        if map_id == "" then
            map_id_entity = minetest.add_entity(pos, "mcl_itemframes:glow_item")
            map_id_lua = map_id_entity:get_luaentity()
            map_id_lua._nodename = node.name
            if 1 == 1 then
                minetest.log("action", "[mcl_itemframes] Update_Glow_Item: Adding entity: " .. map_id_lua.name)
            end

            local itemname = item:get_name()
            if itemname == "" or itemname == nil then
                map_id_lua._texture = "blank.png"
                map_id_lua._scale = 1
                map_id_lua.glow = glow_amount
            else
                map_id_lua._texture = itemname
                local def = minetest.registered_items[itemname]
                map_id_lua._scale = def and def.wield_scale and def.wield_scale.x or 1
            end
            if 1 == 1 then
                minetest.log("action", "[mcl_itemframes] Update_Glow_Item: item's name: " .. itemname)
            end
            map_id_lua:_update_texture()
            if node.name == "mcl_itemframes:glow_item_frame" then
                map_id_entity:set_yaw(yaw)
            end
        else
            map_id_entity = minetest.add_entity(pos, "mcl_itemframes:glow_map", map_id)
            map_id_entity:set_yaw(yaw)
            if 1 == 1 then
                minetest.log("action", "[mcl_itemframes] Placing map in a glow frame.")
            end
        end
    end
end

mcl_itemframes.update_item_entity = function(pos, node, param2)
    if 1 == 1 then
        minetest.log("action", "[mcl_itemframes] Update_Item_Entity:\nPosition: " .. dump(pos) .. "\nNode: " .. dump(node))
    end
    remove_item_entity(pos, node)
    local meta = minetest.get_meta(pos)
    local inv = meta:get_inventory()
    local item = inv:get_stack("main", 1)
    if not item:is_empty() then
        if not param2 then
            param2 = node.param2
        end
        if node.name == "mcl_itemframes:item_frame" then
            local posad = facedir[param2]
            pos.x = pos.x + posad.x * 6.5 / 16
            pos.y = pos.y + posad.y * 6.5 / 16
            pos.z = pos.z + posad.z * 6.5 / 16
        end
        local yaw = pi * 2 - param2 * pi / 2
        local map_id = item:get_meta():get_string("mcl_maps:id")
        local map_id_entity = {}
        local map_id_lua = {}

        if map_id == "" then
            map_id_entity = minetest.add_entity(pos, "mcl_itemframes:item")

            map_id_lua = map_id_entity:get_luaentity()

            if DEBUG then
                minetest.log("[mcl_itemframes] Map_ID_Entity: \n" .. dump(map_id_entity))
                minetest.log("[mcl_itemframes] Map_ID_LUA: \n" .. dump(map_id_lua))
            end

            map_id_lua._nodename = node.name
            local itemname = item:get_name()
            if itemname == "" or itemname == nil then
                map_id_lua._texture = "blank.png"
                map_id_lua._scale = 1
            else
                map_id_lua._texture = itemname
                local def = minetest.registered_items[itemname]
                map_id_lua._scale = def and def.wield_scale and def.wield_scale.x or 1
            end
            map_id_lua:_update_texture()
            if node.name == "mcl_itemframes:item_frame" then
                map_id_entity:set_yaw(yaw)
            end
        else
            map_id_entity = minetest.add_entity(pos, "mcl_itemframes:map", map_id)
            map_id_entity:set_yaw(yaw)
        end
    end
end

local drop_item = function(pos, node, meta, clicker)
    local cname = ""
    if clicker and clicker:is_player() then
        cname = clicker:get_player_name()
    end
    if not minetest.is_creative_enabled(cname) then
        if (node.name == "mcl_itemframes:item_frame" or node.name == "mcl_itemframes:glow_item_frame") then
            local inv = meta:get_inventory()
            local item = inv:get_stack("main", 1)
            if not item:is_empty() then
                minetest.add_item(pos, item)
            end
        end
    end

    meta:set_string("infotext", "")
    remove_item_entity(pos, node)
end
mcl_itemframes.item_frame_base = {
    description = S("Item Frame"),
    _tt_help = S("Can hold an item"),
    _doc_items_longdesc = S("Item frames are decorative blocks in which items can be placed."),
    _doc_items_usagehelp = S("Just place any item on the item frame. Use the item frame again to retrieve the item."),
    drawtype = "mesh",
    is_ground_content = false,
    mesh = "mcl_itemframes_itemframe1facedir.obj",
    selection_box = { type = "fixed", fixed = { -6 / 16, -6 / 16, 7 / 16, 6 / 16, 6 / 16, 0.5 } },
    collision_box = { type = "fixed", fixed = { -6 / 16, -6 / 16, 7 / 16, 6 / 16, 6 / 16, 0.5 } },
    tiles = { "mcl_itemframes_item_frame_back.png", "mcl_itemframes_item_frame_back.png", "mcl_itemframes_item_frame_back.png", "mcl_itemframes_item_frame_back.png", "default_wood.png", "mcl_itemframes_item_frame_back.png" },
    inventory_image = "mcl_itemframes_item_frame.png",
    wield_image = "mcl_itemframes_item_frame.png",
    use_texture_alpha = minetest.features.use_texture_alpha_string_modes and "opaque" or false,
    paramtype = "light",
    paramtype2 = "facedir",
    sunlight_propagates = true,
    groups = { dig_immediate = 3, deco_block = 1, dig_by_piston = 1, container = 7, attached_node_facedir = 1 },
    sounds = mcl_sounds.node_sound_defaults(),
    node_placement_prediction = "",
    on_timer = function(pos)
        local inv = minetest.get_meta(pos):get_inventory()
        local stack = inv:get_stack("main", 1)
        local itemname = stack:get_name()
        if minetest.get_item_group(itemname, "clock") > 0 then
            local new_name = "mcl_clock:clock_" .. (mcl_worlds.clock_works(pos) and mcl_clock.old_time or mcl_clock.random_frame)
            if itemname ~= new_name then
                stack:set_name(new_name)
                inv:set_stack("main", 1, stack)
                local node = minetest.get_node(pos)
                mcl_itemframes.update_item_entity(pos, node, node.param2)
            end
            minetest.get_node_timer(pos):start(1.0)
        end
    end,
    on_place = function(itemstack, placer, pointed_thing)
        if pointed_thing.type ~= "node" then
            return itemstack
        end

        -- Use pointed node's on_rightclick function first, if present
        local node = minetest.get_node(pointed_thing.under)
        if placer and not placer:get_player_control().sneak then
            if minetest.registered_nodes[node.name] and minetest.registered_nodes[node.name].on_rightclick then
                return minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack) or itemstack
            end
        end

        return minetest.item_place(itemstack, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
    end,
    on_construct = function(pos)
        local meta = minetest.get_meta(pos)
        local inv = meta:get_inventory()
        inv:set_size("main", 1)
    end,
    on_rightclick = function(pos, node, clicker, itemstack)
        if not itemstack then
            return
        end
        local pname = clicker:get_player_name()
        if minetest.is_protected(pos, pname) then
            minetest.record_protection_violation(pos, pname)
            return
        end
        local meta = minetest.get_meta(pos)
        drop_item(pos, node, meta, clicker)
        local inv = meta:get_inventory()
        if itemstack:is_empty() then
            remove_item_entity(pos, node)
            meta:set_string("infotext", "")
            inv:set_stack("main", 1, "")
            return itemstack
        end
        local put_itemstack = ItemStack(itemstack)
        put_itemstack:set_count(1)
        local itemname = put_itemstack:get_name()
        if minetest.get_item_group(itemname, "compass") > 0 then
            put_itemstack:set_name(mcl_compass.get_compass_itemname(pos, minetest.dir_to_yaw(minetest.facedir_to_dir(node.param2)), put_itemstack))
        end
        if minetest.get_item_group(itemname, "clock") > 0 then
            minetest.get_node_timer(pos):start(1.0)
        end
        inv:set_stack("main", 1, put_itemstack)
        if node.name == "mcl_itemframes:item_frame" then
            mcl_itemframes.update_item_entity(pos, node)
        elseif node.name == "mcl_itemframes:glow_item_frame" then
            mcl_itemframes.update_item_glow_entity(pos, node)
        end

        -- Add node infotext when item has been named
        local imeta = itemstack:get_meta()
        local iname = imeta:get_string("name")
        if iname then
            meta:set_string("infotext", iname)
        end

        if not minetest.is_creative_enabled(clicker:get_player_name()) then
            itemstack:take_item()
        end
        return itemstack
    end,
    allow_metadata_inventory_move = function(pos, from_list, from_index, to_list, to_index, count, player)
        local name = player:get_player_name()
        if minetest.is_protected(pos, name) then
            minetest.record_protection_violation(pos, name)
            return 0
        else
            return count
        end
    end,
    allow_metadata_inventory_take = function(pos, listname, index, stack, player)
        local name = player:get_player_name()
        if minetest.is_protected(pos, name) then
            minetest.record_protection_violation(pos, name)
            return 0
        else
            return stack:get_count()
        end
    end,
    allow_metadata_inventory_put = function(pos, listname, index, stack, player)
        local name = player:get_player_name()
        if minetest.is_protected(pos, name) then
            minetest.record_protection_violation(pos, name)
            return 0
        else
            return stack:get_count()
        end
    end,
    on_destruct = function(pos)
        local meta = minetest.get_meta(pos)
        local node = minetest.get_node(pos)
        drop_item(pos, node, meta)
    end,
    on_rotate = function(pos, node, user, mode, param2)
        if mode == screwdriver.ROTATE_FACE then
            -- Rotate face
            --local meta = minetest.get_meta(pos)
            local node = minetest.get_node(pos)

            local objs = nil
            if node.name == "mcl_itemframes:item_frame" or node.name == "mcl_itemframes:glow_item_frame" then
                objs = minetest.get_objects_inside_radius(pos, 0.5)
            end
            if objs then
                for _, obj in ipairs(objs) do
                    if obj and obj:get_luaentity() then
                        if obj:get_luaentity().name == "mcl_itemframes:item" then
                            mcl_itemframes.update_item_entity(pos, node, (node.param2 + 1) % 4)
                            break
                        end
                        if obj:get_luaentity().name == "mcl_itemframes:glow_item_frame" then
                            mcl_itemframes.update_item_glow_entity(pos, node, (node.param2 + 1) % 4)
                            break
                        end
                    end
                end
            end
            return
        elseif mode == screwdriver.ROTATE_AXIS then
            return false
        end
    end,
}

function mcl_itemframes.create_item_entity()
    if 1 == 1 then
        minetest.log("action", "[mcl_itemframes] create_item_entity.")
    end

    --"mcl_itemframes:item",
    local frame_item = {
        hp_max = 1,
        visual = "wielditem",
        visual_size = { x = VISUAL_SIZE, y = VISUAL_SIZE },
        physical = false,
        pointable = false,
        textures = { "blank.png" },
        _texture = "blank.png",
        _scale = 1,

        on_activate = function(self, staticdata)
            if staticdata and staticdata ~= "" then
                local data = staticdata:split(";")
                if data and data[1] and data[2] then
                    self._nodename = data[1]
                    self._texture = data[2]
                    if data[3] then
                        self._scale = data[3]
                    else
                        self._scale = 1
                    end
                end
            end
            if self._texture then
                self.object:set_properties({
                    textures = { self._texture },
                    visual_size = { x = VISUAL_SIZE / self._scale, y = VISUAL_SIZE / self._scale },
                })
            end
        end,
        get_staticdata = function(self)
            if self._nodename and self._texture then
                local ret = self._nodename .. ";" .. self._texture
                if self._scale then
                    ret = ret .. ";" .. self._scale
                end
                return ret
            end
            return ""
        end,

        _update_texture = function(self)
            if self._texture then
                self.object:set_properties({
                    textures = { self._texture },
                    visual_size = { x = VISUAL_SIZE / self._scale, y = VISUAL_SIZE / self._scale },
                })
            end
        end,
    }
    -- "mcl_itemframes:map",
    local map_item = {
        initial_properties = {
            visual = "upright_sprite",
            visual_size = { x = 1, y = 1 },
            pointable = false,
            physical = false,
            collide_with_objects = false,
            textures = { "blank.png" },
        },
        on_activate = function(self, staticdata)
            self.id = staticdata
            mcl_maps.load_map(self.id, function(texture)
                -- will not crash even if self.object is invalid by now
                self.object:set_properties({ textures = { texture } })
            end)
        end,
        get_staticdata = function(self)
            return self.id
        end,
    }

    local glow_frame_item = table.copy(frame_item)
    glow_frame_item.glow = glow_amount
    glow_frame_item.name = "mcl_itemframes:glow_item"
    local glow_frame_map_item = table.copy(map_item)
    glow_frame_map_item.glow = glow_amount
    glow_frame_map_item.name = "mcl_itemframes:glow_map"

    minetest.register_entity("mcl_itemframes:glow_item", glow_frame_item)
    minetest.register_entity("mcl_itemframes:glow_map", glow_frame_map_item)
    minetest.register_entity("mcl_itemframes:item", frame_item)
    minetest.register_entity("mcl_itemframes:map", map_item)

end
mcl_itemframes.create_item_entity()

function mcl_itemframes.update_frame_registry(modname, name, has_glow)
    local mod_name_pass = false
    if modname ~= "" and modname ~= "false" then
        if minetest.get_modpath(modname) then
            mod_name_pass = true
        end
        if mod_name_pass == false then
            return
        end
    end

    mcl_itemframes.frames_registered.glowing = {}
    mcl_itemframes.frames_registered.standard = {}

    local frame = "mcl_itemframes:" .. name
    if has_glow == true then
        table.insert(mcl_itemframes.frames_registered.glowing, frame)
    else
        table.insert(mcl_itemframes.frames_registered.standard, frame)
    end

end

function mcl_itemframes.create_custom_frame(modname, name, has_glow, tiles, color, ttframe, description)
    local mod_name_pass = false
    if modname ~= "" and modname ~= "false" then
        if minetest.get_modpath(modname) then
            mod_name_pass = true
        end
        if mod_name_pass == false then
            return
        end
    end
    if name == nil then
        name = ""
    end

    if has_glow == nil or has_glow == "" then
        has_glow = false
    end

    if tiles == nil or tiles == "" then
        minetest.log("error", "No textures passed to Create_Custom_Frame!! Exiting frame creation.")
        return
    end

    local custom_itemframe_definition = {}

    if has_glow == false then
        custom_itemframe_definition = table.copy(mcl_itemframes.item_frame_base)
    else
        custom_itemframe_definition = table.copy(mcl_itemframes.glow_frame_base)
    end

    custom_itemframe_definition.tiles = { "(" .. tiles .. "^[multiply:" .. color .. ")" }
    custom_itemframe_definition._tt_help = ttframe
    custom_itemframe_definition.description=description
    mcl_itemframes.update_frame_registry(modname, name, has_glow)
    mcl_itemframes.create_register_lbm(name, has_glow)

end

function mcl_itemframes.create_base_frames()
    if 1 == 1 then
        minetest.log("action", "[mcl_itemframes] create_frames.")
    end

    minetest.register_node("mcl_itemframes:item_frame", mcl_itemframes.item_frame_base)

    -- make glow frame from the base item_frame.
    mcl_itemframes.glow_frame_base = table.copy(mcl_itemframes.item_frame_base)
    mcl_itemframes.glow_frame_base.description = S("Glow Item Frame")
    mcl_itemframes.glow_frame_base._tt_help = S("Can hold an item and glows")
    mcl_itemframes.glow_frame_base.longdesc = S("Glow item frames are decorative blocks in which items can be placed.")
    mcl_itemframes.glow_frame_base.tiles = { "mcl_itemframes_glow_item_frame.png" }
    mcl_itemframes.glow_frame_base.inventory_image = "mcl_itemframes_glow_item_frame_item.png"
    mcl_itemframes.glow_frame_base.wield_image = "mcl_itemframes_glow_item_frame.png"
    mcl_itemframes.glow_frame_base.mesh = "mcl_itemframes_glow_item_frame.obj"

    --mcl_itemframes.glow_frame_base.light_source = minetest.LIGHT_MAX -- add in glow (a hack at best, but it's a node) TODO: make actual glow.
    mcl_itemframes.glow_frame_base.on_timer = function(pos)
        local inv = minetest.get_meta(pos):get_inventory()
        local stack = inv:get_stack("main", 1)
        local itemname = stack:get_name()
        if minetest.get_item_group(itemname, "clock") > 0 then
            local new_name = "mcl_clock:clock_" .. (mcl_worlds.clock_works(pos) and mcl_clock.old_time or mcl_clock.random_frame)
            if itemname ~= new_name then
                stack:set_name(new_name)
                inv:set_stack("main", 1, stack)
                local node = minetest.get_node(pos)
                mcl_itemframes.update_item_glow_entity(pos, node, node.param2)
            end
            minetest.get_node_timer(pos):start(1.0)
        end
    end

    minetest.register_node("mcl_itemframes:glow_item_frame", mcl_itemframes.glow_frame_base)

    mcl_itemframes.update_frame_registry("false", "item_frame", false)
    mcl_itemframes.update_frame_registry("false", "glow_item_frame", true)
    mcl_itemframes.create_register_lbm("item_frame", false)
    mcl_itemframes.create_register_lbm("glow_item_frame", true)
end

function mcl_itemframes.create_register_lbm(name, has_glow)

    -- FIXME: Item entities can get destroyed by /clearobjects
    -- glow frame
    minetest.register_lbm({
        label = "Respawn item frame item entities",
        name = "mcl_itemframes:respawn_entities",
        nodenames = { "mcl_itemframes:" .. name },
        run_at_every_load = true,
        action = function(pos, node)
            if has_glow == true then
                mcl_itemframes.update_item_glow_entity(pos, node)
            else
                mcl_itemframes.update_item_entity(pos, node)
            end
        end,
    })

end

